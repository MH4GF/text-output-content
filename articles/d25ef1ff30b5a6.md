---
title: "ProseMirror Guide(日本語訳)"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [リッチテキストエディタ,ProseMirror]
published: false
---

# TODO
- [ ] 一旦の和訳(進行中)
- [ ] 日本語として滑らかに読めるように推敲
- [ ] リンク先を埋める
- [ ] どの用語を英語のまま保つか考える
  - node, fragment, document, transaction

https://prosemirror.net/docs/guide/

このガイドでは、ライブラリで使われているさまざまな概念と、それらの相互関係について説明します。システムの全体像を把握するためには、少なくともview componentのセクションまでは提示された順序で通して読むことをお勧めします。

# Introduction

ProseMirrorはリッチテキストエディタを構築するためのツールとコンセプトの両方を提供します。 what-you-see-is-what-you-getに触発されたUIを使用しながら、その編集スタイルの落とし穴を避けることに取り組んでいます。

ProseMirrorの大原則は、書いたコードがドキュメント全体とその中で起こることを完全に制御することです。このドキュメントはHTMLのblobではないですが、あなたが明示的に許可しかつ指定した関係の要素のみを含むカスタムデータ構造です。すべての更新は一ヵ所を経由し、そこでチェックし対応できます。

コアライブラリはすぐ利用可能なドロップインコンポーネントというわけではありません。私たちはモジュール性やカスタマイズ性をシンプル性よりも重視しています(将来的には人々がProseMirrorをベースとしたドロップインエディタを配布してほしいという願いも込めて)。これはMatchbox carというよりレゴのセットです。

編集する上で必須な4つのモジュールがあり、さらにコアチームによって保守されている数々の拡張モジュールがあり、それらはサードパーティモジュールと同様に便利な機能を提供します。それらを組み合わせたり、除外したり、または同様の機能を実装し置き換えることができます。

必須モジュールは以下です。

- [prosemirror-model](https://prosemirror.net/docs/ref/#model) はエディタの[ドキュメントモデル](https://prosemirror.net/docs/guide/#doc)で、記事コンテンツを表すために使われるデータ構造です。
- [prosemirror-state](https://prosemirror.net/docs/ref/#state) はエディタの状態を表すデータ構造で、選択や、1つの状態から次に遷移するためのトランザクションシステムを含みます。
- [prosemirror-view](https://prosemirror.net/docs/ref/#view) は与えられたエディタの状態(Editor State)をブラウザで編集可能な要素として表示するインタフェース・コンポーネントを実装し、その要素とのユーザーインタラクションを処理します。
- [prosemirror-transform](https://prosemirror.net/docs/ref/#transform) は記録と再生が可能な形でドキュメントの修正ができる機能を含み、それは state モジュールのトランサクションを基本とし、さらにundo historyや共同編集を可能にしています。

加えて、[基本の編集コマンド]()や、[キーバインディング]()、[undo history]()、[input macros](), [共同編集]()、[シンプルなドキュメントスキーマ]()など、さらに多くの拡張モジュールが[prosemirrorのGitHub Organization]()に用意されています。

ProseMirrorは単一のブラウザでロード可能なスクリプトとして配布されていないため、利用する際は何らかのバンドラーを必要とするかもしれません。バンドラーとは自動的にスクリプトの依存を自動的に検出し、Webページがロードしやすいように1つの大きなファイルとして結合します。Web向けのバンドリングについては[こちらのexampleを読むと良いでしょう。]()

## My first editor

このようにレゴのピースを組み合わせて、非常にミニマルなエディタを作ることができます。

```
import {schema} from "prosemirror-schema-basic"
import {EditorState} from "prosemirror-state"
import {EditorView} from "prosemirror-view"

let state = EditorState.create({schema})
let view = new EditorView(document.body, {state})
```

ProseMirrorはドキュメントが準拠するスキーマ(schema)を指定する必要があります。ということで、まず最初は基本スキーマを含むモジュールをインポートします。

そのスキーマを使ってstateが作られ、スキーマに準拠した空のドキュメントが生成され、さらにデフォルトの選択範囲がドキュメントの始めに設定されます。最後に、ビューがstateから作成され、document.bodyに挿入されます。これはstateのドキュメントが編集可能なDOMノードとしてレンダリングされ、そしてユーザーが入力する度にstate transactionを生成します。

エディタはまだあまり使い勝手が良くありません。たとえばEnterキーを押しても何も起きません、なぜならコアライブラリはエンターキーが何をすべきかについて何の意見も持っていないからです。その話はまた今度。

# Transactions

ユーザーが入力するなどしてビューと対話するとき、'state transactions' が生成されます。それがどういう意味かというと、単にドキュメントを直接更新し、暗黙のうちにその状態を更新するのではないことを意味します。その代わりに、すべての変更は状態に対する変更を記述した[トランザクション]()が作成されることによって引き起こされます。

デフォルトではこれらはすべて暗黙のうちに行われますが、[プラグイン]()を書いたりビューを設定することによってフックできます。たとえばこのコードは [dispatchTransaction prop]() を追加しており、これはトランザクションが作成されるたびに呼び出されます。

```
// (importは省略)

let state = EditorState.create({schema})
let view = new EditorView(document.body, {
  state,
  dispatchTransaction(transaction) {
    console.log("Document size went from", transaction.before.content.size,
                "to", transaction.doc.content.size)
    let newState = view.state.apply(transaction)
    view.updateState(newState)
  }
})
```

stateの更新はすべて `updateState` を経由する必要があり、すべての通常の編集はトランザクションをディスパッチすることによって行われます。

# Plugins

プラグインはエディタの振る舞いやエディタの状態をさまざまな方法で拡張するために使用されます。比較的簡単なものもあり、キーボード入力にアクションをバインドする `keymap` プラグインのようなものです。ほかにはより深く関わるものとして、トランザクションを監視し、ユーザーが戻したい場合に備えてその逆を保存しundo historyを実装する `history` プラグインのようなものです。

それではこれらの2つのプラグインを追加し、前に戻す/先に進む機能を手に入れましょう

```
// (Omitted repeated imports)
import {undo, redo, history} from "prosemirror-history"
import {keymap} from "prosemirror-keymap"

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({"Mod-z": undo, "Mod-y": redo})
  ]
})
let view = new EditorView(document.body, {state})
```

プラグインはstate作成時に登録されました（なぜなら彼らは状態トランザクションにアクセスできるからです）。その後履歴が有効な状態のビューが作成され、Ctrl-Z(macOSではCmd-Z)で前の変更に戻すことができます。

# Commands

前の例でキーにバインドした `undo` と `redo` は、Commandと呼ばれる特殊な関数です。ほとんどの編集操作はコマンドとして記述され、キーにバインドされたり、メニューに追加されたり、ユーザーに公開されるようになっています。

`prosemirror-commands` パッケージは基本的な編集コマンドとともに最小限のキーマップが数多く提供されており、enterやdeleteといった操作をエディタで行うことができます。

```
// (Omitted repeated imports)
import {baseKeymap} from "prosemirror-commands"

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({"Mod-z": undo, "Mod-y": redo}),
    keymap(baseKeymap)
  ]
})
let view = new EditorView(document.body, {state})
```

この時点で、基本的に動作するエディタが完成しました。

メニューを追加したり、スキーマ固有のキーバインディングを追加したりする場合、`prosemirror-example-setup` パッケージを見ると良いでしょう。これは基本的なエディタをセットアップするプラグインの配列を提供するモジュールですが、その名の通りプロダクションレベルとしてではなくあくまで一例という意味です。現実世界にデプロイするためには、自身のコードに置き換えて希望通りの設定にすることをお勧めします。

# Content

stateのドキュメントは `doc` プロパティの下にいます。これはreadonlyなデータ構造で、ドキュメントをノードの階層として表現し、ブラウザのDOMに多少似ています。シンプルなドキュメントでは、 `doc` ノードが2つの `paragraph` ノードを含み、それらは単一の `text` ノードを持ちます。ドキュメントのデータ構造についてはこのガイドで詳しく説明されています。

stateが初期化された時、初期ドキュメントを付与できます。スキーマはドキュメントから取得できるため、 `schema` フィールドは省略可能です。

ここでは `content` IDのDOM要素で見つかったコンテンツを解析して state を初期化します。DOMパーサ機構を利用し、どのDOMノードがスキーマのどの要素に対応するかの情報を利用します。

```
import {DOMParser} from "prosemirror-model"
import {EditorState} from "prosemirror-state"
import {schema} from "prosemirror-schema-basic"

let content = document.getElementById("content")
let state = EditorState.create({
  doc: DOMParser.fromSchema(schema).parse(content)
})
```

# Documents

ProseMirrorはドキュメント内容を表現する独自のデータ構造を定義します。ドキュメントはエディタのほかの部分を構成する中心的な要素のため、ドキュメントがどのように機能するかを理解することは有用です。

## Structure

ProseMirrorのドキュメントは `node` で、それは0個以上の子ノードが含まれた `fragment` を持ちます。
これは再帰的でツリー型である点でブラウザのDOMによく似ています。しかしDOMとはインラインコンテンツの保存方法で違いがあります。

HTMLでは、マークアップがある段落は木で表現されます。このように

```
<p>This is <strong>strong text with <em>emphasis</em></strong></p>
```

画像

一方ProseMirrorでは、インラインコンテンツはフラットなシーケンスでモデル化され、マークアップはメタデータとしてノードに付与されます。

画像

この方が私たちがこのようなテキストを考え、扱う方法に近いと思います。これにより段落内の位置をツリー内のパスではなく文字のオフセットで表現できるようになり、さらに簡単にしました、分割やコンテンツのスタイル変更の操作を、やっかいなツリー操作なしに。

これはまた意味しますすべてのドキュメントはそれぞれ有効な1つの表現を持つことを。同じマークアップのセットを持つ隣接するテキストノードは常に一緒に結合され、空のテキストノードは許されません。マークが表出する順序はスキーマによって定義されます。

つまり、ProseMirrorのドキュメントはブロックノードのツリーであり、ほとんどのリーフノードは `textblocks` で、テキストが含まれたブロックノードです。あなたは持つこともできます単純な空のリーフブロックを、たとえば区切り線や動画要素で。

ノードオブジェクトにはいくつかのプロパティが付属しています、ドキュメント内で果たす役割を反映した

- `isBlock` と `isInline` 与えられたノードがブロックかインラインかを示します。
- `inlineContent` はインラインノードをコンテンツとして想定しているノードの場合trueとなります。
- `isTextBlock` はインラインコンテンツを持つブロックノードの場合trueとなります。
- `isLeaf` はノードがどのコンテンツも許可しないことを示します。

つまり典型的な `paragraph` ノードはtextblockになり、その一方で blockquoteはほかのブロックからなるブロック要素です。テキストや、改行、インライン画像はインラインなリーフのーどで、区切り線ノードはブロックリーフノードの一例です。

`schema` はどこに何を表示するかについてより正確な制約を指定できます。すなわち、あるノードがブロックコンテンツを許可していても、それはすべてのブロックのーどをコンテンツとして許可することを意味しているわけではありません。

# Idエンティティ and persistence

もう1つの重要なDOMツリーとProseMirrorドキュメントの違いは、ノードを表すオブジェクトの動作方法です。DOMでは、ノードは同一性を持つミュータブルなオブジェクトであり、それは意味しますノードが1つの親ノードにのみ表示でき、またノードオブジェクトが更新された時に変化されます。

一方ProseMirrorでは、ノードはシンプルな値で、数字の「3」を表す値と同じようにアプローチする必要があります。3は複数のデータ構造で同時に表示でき、親のリンクを持たない現在所属しているデータ構造に対して、またそれに1を足した場合、4という新しい値を得ることができ、それはオリジナルである3は何も変えずに。

ProseMirrorドキュメントの一部もそうです。それらは変更せずに、修正されたドキュメントの一部を計算するための開始値として使用できる。それらは彼らが含まれているデータ構造が何かを知らないが、複数の構造の一部に所属でき、1つの構造体に複数回出現することもある。これらは値であり、ステートフルなオブジェクトではありません。

これは意味します。あなたがドキュメントを更新するすべての時間であなたは新しいドキュメントの値を得ることができることを。ドキュメントの値は共有されます すべてのサブノードに もともとのドキュメントの値を変更することなく比較的安価に作成できます。

これにはたくさんのアドバンテージがあります。新しいドキュメントを含む新しいstateを瞬時に入れ替えることができるため、アップデート中にエディタが無効な状態になることを不可能にします。また、簡単にします ドキュメントをある程度数学的に推論するkとを これはとても難しい もしあなたの値があなたの知らないところで変更し続けていたとしたら。 これは共同編集を可能にし、許可します ProseMirrorがとても効率的な DOMの更新アルゴリズムを実行することを助けます 画面に描写された最後のドキュメントと現在のドキュメントを比較し

このようなノードは標準のJavaScriptオブジェクトで表現され、そのプロパティを凍結するとパフォーマンスが低下するため実際には変更は可能です。しかしそのような行為はサポートされていません。また破壊を引き起こします なぜなら彼らはだいたいの場合複数のデータ構造間で共有されるからです。注意してください！
また注意してください 適用されること ノードオブジェクトの一部である配列やプレーンオブジェクト、たとえばノードの属性を保存するためのオブジェクト、またフラグメントの子ノードの配列にも

# Data structures

ドキュメントのオブジェクト構造はこのようになっています:

画像

それぞれのオブジェクトは `Node` クラスのインスタンスとして表現されます。これは `type` によってタグづけされ、nodeの名前やそのnodeに対して有効な属性などを知っています。 node type (mark type)はスキーマごとに1つ作成され、それらがスキーマの一部であるかを知ることができます。

nodeのコンテンツは `Fragment` のインスタンスとして保存され、nodeのシーケンスを保持します。コンテンツを持たない、あるいはコンテンツを許可しないノードに対しても、このフィールドは（共有された空のFragmentで）満たされます。

いくつかのnode typeは各nodeに保存される追加の値を属性として利用できます。たとえばimage nodeはaltテキストやimageのURLを保存する必要があるかもしれません。

加えて、インラインノードはアクティブなmarkのセットを保持できます。強調やリンクなど それらは `Mark` のインスタンスの配列として表現されます。

全体のドキュメントも単なるnodeです。ドキュメントのコンテンツは、トップレベルノードの子ノードとして表現されます。つまり、それは一連のブロックノードを含み、そのうちのいくつかはインラインコンテンツを含むテキストブロックかもしれません。しかしトップレベルのノードもテキストブロックそのものである場合もあり、その場合、ドキュメントはインラインコンテンツのみを含むことになります。

どのようなノードがどこに許されるかはドキュメントのスキーマによって決定されます。プログラムでノードを作成するためにはスキーマを経由する必要があります。nodeメソッドやtextメソッドなどを使って。

```
import {schema} from "prosemirror-schema-basic"

// (The null arguments are where you can specify attributes, if necessary.)
let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("One.")]),
  schema.node("horizontal_rule"),
  schema.node("paragraph", null, [schema.text("Two!")])
])
```

# Indexing

ProseMirrorのノードは2つのタイプのindexingをサポートします。個々のノードへのオフセットを使用して木構造として扱うことも、トークンのフラットなシーケンスとして扱うこともできます。

1つ目はDOMで行うのと同じようなことができます。単一のノードに作用し、 `child method` や `childCount` を使って直接子ノードにアクセスします、ドキュメントを走査する再帰的な関数を書く（すべてのノードを見たいだけなら、 `descendants` や `nodeBetween` を使います。）

2つ目は、ドキュメントの特定の位置を取り上げる場合に有効です。それはドキュメントの位置をIntegerのトークンのインデックスとして表現します。これらのトークンは実際にはメモリ上のオブジェクトとして存在しないーthey are just a counting conventionーしかしドキュメントのツリー形状や。各ノードが自身のサイズを知っているという事実があり、位置によるアクセスは安価に実現できる。

- ドキュメントの開始値、最初のコンテンツの直前がposition 0です
- リーフノードでないノード（コンテンツをサポートしているノード）への入退出は1トークンと数える。つまりドキュメントがparagraphで始まる場合、paragraphの開始値は1と数える。
- テキストノードの一文字は1トークンとして数えます。つまりもしparagraphがドキュメントの開始で `hi` というWordを含んでいる場合、 position 2は `h` の後、position 3は `i` の後、position 4はparagraph全体の後にあります。
- リーフノードはコンテンツを含まないため（画像のように）、それもまた1トークンと数えます。

つまりHTMLで表現すると、次のようなドキュメントがあるとします。

```
<p>One</p>
<blockquote><p>Two<img src="..."></p></blockquote>
```

位置を含むトークンシーケンスは次のようになります。

```
0   1 2 3 4    5
 <p> O n e </p>

5            6   7 8 9 10    11   12            13
 <blockquote> <p> T w o <img> </p> </blockquote>
```

それぞれのノードは `nodeSize` プロパティを持ち、それはノード全体のサイズを提供し、また `.content.size` は ノードのコンテンツのサイズにアクセスできます。なお、外側のドキュメントノードでは、openとcloseのトークンはドキュメントの一部とはみなされないため（カーソルをドキュメントの外側に置くことはできないため）、ドキュメントのサイズは `doc.nodeSize` ではなく `doc.content.size` になります。

このようなpositionを手作業で解釈するにはかなり多くのカウントが必要です。 `Node.resolve` を呼び出すと、位置についてのより詳細なデータ構造を取得できます。データ構造は親ノードのポジションを教えたり、親からのオフセットであったり、どの祖先を親が持っているかなど多くの事柄を伝えます。

`childCount` によるドキュメント全体の位置や、ノードローカルなオフセット（再起的関数で現在処理されているノードの位置を表すために使われる）を区別するように注意すること。

# Slices

コピー&ペーストやドラッグ&ドロップをハンドルするために、ドキュメントのスライス、つまり2つの位置間のコンテンツについて話す必要があります。そのようなスライスはフルノードやフラグメントとは異なり開始点や終点が「開いている」可能性があります。

たとえば、あるparagraphの途中から次のparagraphの途中を選択した場合、選択したスライスには2つのparagraphが含まれます。paragraphそのものをノード選択するとノードに閉じた選択が行われるのに対して、1つ目の方は開始側が開き、2つ目の方は終了側が開きます。このようなオープンなノードでは、必要なノードがスライスの外に出てしまったため、ノードの全内容と同様に扱うとスキーマの制約に違反する場合があります。

[Slice]()のデータ構造はそのようなスライスを表すために使われます。それは左右の[open depth]()に沿って[flagment]()を保存します。ノードの[sliceメソッド]()を使うと、ドキュメントをスライスして切り出すことができます。

```
// doc holds two paragraphs, containing text "a" and "b"
let slice1 = doc.slice(0, 3) // The first paragraph
console.log(slice1.openStart, slice1.openEnd) // → 0 0
let slice2 = doc.slice(1, 5) // From start of first paragraph
                             // to end of second
console.log(slice2.openStart, slice2.openEnd) // → 1 1
```

# Changing

node と fragment は[永続的](https://en.wikipedia.org/wiki/Persistent_data_structure)であるため、けっしてmutateしてはいけません。もしあなたがdocument(もしくはnodeやfragment)のハンドルを持っている場合、そのオブジェクトは同じままです。

ほとんどの場合、[transform]()を使ってドキュメントを更新し、ノードを直接触ることはないでしょう。transformは変更の履歴も残します。これはドキュメントがeditor stateの一部である場合に必要です。

更新されたドキュメントを「手動で」導き出したい場合、ヘルパーメソッドが [Node]()と[Fragment]()型で利用可能です。ドキュメント全体の更新されたバージョンを作成するには、通常 [Node.replace]()を使用します。これは、ドキュメントの任意の範囲を新しいコンテンツの[slice]()で置き換えます。node を浅く(shallowly)更新する場合、[copy]()メソッドを使うと新しいコンテンツが含まれて同様のnodeを作成できます。Fragmentも [replaceChild]()や[append]()のようなさまざまな更新メソッドを持ちます。

# Schemas

それぞれの ProseMirror [document]()には[schema]()が関連付けられています。schemaはドキュメント内でnodeが何が起こるかが記述されており、彼らがネストされる方法も。たとえば、トップレベルのnodeは1つかそれ以上のブロックを含むと言うことができ、またparagraph nodeはいくつかの数のインライン nodeを含み、それらにはいくつかの[marks]()が付与されています。

これらは[basic schema]()パッケージで利用可能で、しかしすばらしいこととしてはProseMirrorはあなた自身でschemaを定義できると言うこと。

# Node Types

ドキュメント内のすべてのnodeは[type]()を持ち、それはセマンティックな意味とプロパティが表現され、つまりエディタでどのようにレンダリングするかを表す。

schemaを定義するとき、あなたは何が起こるかのnode typeを列挙できる、[spec object]()を利用して。

```
const trivialSchema = new Schema({
  nodes: {
    doc: {content: "paragraph+"},
    paragraph: {content: "text*"},
    text: {inline: true},
    /* ... and so on */
  }
})
```

このschemaはdocumentが1つかそれ以上のparagraphが含まれることを定義しており、またそれぞれのparagraphはいくつかのtextを含むことができる。

schemaは1つ以上のトップレベルなnode(デフォルトでは `doc` と言う名前だが[設定]()することもできる)が必要であり、また `text` typeはテキストコンテンツである。

インラインと数えるnodeは [inline]()プロパティが必要（text type、inlineと定義される、あなたはこれを無視しても良い）

# Content Expressions

上に挙げた例のschemaにある[content]()fieldsの文字列は `content expressions` と呼ばれるものです。それらは一連の子ノードがnode typeに対しての正しさを制御できます。

あなたは言うことができる、たとえば `paragraph` は1つのparagraphと、 `paragraph+` は1つかそれ以上のparagraphと、同様に `paragraph*` は0個かそれ以上のparagraphを意味する。 また `caption?` は0個か1個のcaptionを表す。正規表現のように幅を表すこともできる、たとえば `{2}` は2つのみ、 `{1,5}` は1〜5、 `{2,}` は2つかそれ以上　ノード名の後に。

expressionではシーケンスを連結された作成できる、たとえば `heading paragraph+` は「1つ目はheading、その後1つかそれ以上のparagraph」、さらにパイプ(pipe)オペレータで2つのexpressionの選択を示すこともできる。たとえば `(paragraph | blockquote)+` 

いくつかの要素タイプのグループはschemaに複数回出現する。たとえばあなたがblockノードという概念を持っていて、それはトップレベルにある　しかし引用の中にネストされていることもある。あなたはnode specの [group]()プロパティを使ってノードグループを作ることができる、また次に示すのはグループを表現したものである

```
const groupSchema = new Schema({
  nodes: {
    doc: {content: "block+"},
    paragraph: {group: "block", content: "text*"},
    blockquote: {group: "block", content: "block+"},
    text: {}
  }
})
```

この `block+` は `(paragraph | blockquote)+` と一致する。

常に1つ以上の子ノードを必須とするノードはblockコンテンツ(たとえば `doc` や `blockquote` )を持たせることを推奨する、なぜならブラウザはノードが空の場合完全に崩れ落ちるため、編集がかなり困難になってしまう。

or式(or-expression)では、ノードが出現する順序は重要です。non-optional nodeなデフォルトのインスタンスを作成する際、たとえば[replace step]()の後にもドキュメントがschemaに適合しているかを確認するために、or式の最初の型が使われることになります。それがグループの場合、グループの最初の型(ノードマップで定義されるグループのメンバーの順番で決定される)が使われます。上記の `paragraph` と `blockquote` の位置を切り替えた場合、エディタがブロックノードを作成しようとするやいなやスタックオーバーフローが返るでしょう。 `blockquote` ノードを作成しようとした時にそのノードが必須とするコンテンツは1つ以上のブロックノードで、また別の `blockquote` を作成しようとして…といった具合に。

ライブラリ内のすべてのnode操作関数が、有効なコンテンツを扱っているかをチェックするわけではありません。[transform]()のような上位概念はそうですが、プリミティブなnode作成関数はふつうはせず、代わりに伴情報を提供する責任は呼び出し側にあります。たとえば [NodeType.create]() を使って無効なコンテンツを持つノードを作成することは完全に可能です。 [slices]()の端で'open'なノードについてはこれは合理的なことであるとさえ言えるでしょう。
与えられたノードのコンテンツが有効であることを保証するためにNodeType.createの代わりに使える[createChecked]()関数と、事後チェックのために使える `check` 関数があります。

# Marks

Marksはスタイリングを追加したりほかの情報をインラインコンテンツに追加するために使われます。schemaはすべてのmark type を明示し許可する必要があります。[Mark types]()はnode typesに似たオブジェクトで、markオブジェクトにタグをつけ、そのオブジェクトに関する追加情報を提供するために使われます。

デフォルトでは、インラインコンテンツを含むノードでは、schemaで定義されたすべてのmarksがその子に適用されます。
node specの[marks]()プロパティで設定できます。

これは太字や強調のmarksがparagraph内のテキストでサポートされたシンプルなスキーマで、しかし見出しはありません。

```
const markSchema = new Schema({
  nodes: {
    doc: {content: "block+"},
    paragraph: {group: "block", content: "text*", marks: "_"},
    heading: {group: "block", content: "text*", marks: ""},
    text: {inline: true}
  },
  marks: {
    strong: {},
    em: {}
  }
})
```

marksの集合は、スペースで区切られた文字列のマーク名またはマークグループとして解釈されます。 `_` はワイルドカードとして機能し、空文字列は空の集合に対応します。

# Attributes

ドキュメントスキーマはそれぞれのノードやmarkが持つattributesもまた定義します。ノードタイプは追加のノード定義情報の保存を必要としたい場合、たとえば見出しノードのレベルなど、それはattributesで行うのが最も良い方法です。

```
  heading: {
    content: "text*",
    attrs: {level: {default: 1}}
  }
```

このスキーまでは、すべての見出しノードのインスタンスは .attrs.level にレベルattributesを持ちます。ノードが[作成]()される際に定義されなかった場合、デフォルトの1になteLinkNode。

デフォルト値をattributesに与えなかった場合、attributesを指定せずにそのようなnodeの作成を試みた際にエラーがraiseされます。

また、変換時や[createAndFill]()の呼び出しなど、ライブラリがスキーマの制約を満たしつつそのようなノードを生成できなくなります。このため、このようなノードをスキーマの必須位置に置くことはできません。スキーマ制約を適用するために、エディタはコンテンツに欠けている部分を埋めるために空のノードを生成できる必要があります。

# Serialization and Parsing

ブラウザでそれらを編集できるようにするために、ブラウザのDOMでドキュメントノードを表現できなければなりません。それを行う最も簡単な方法は、node specの[toDOM]()フィールドを使用してそれぞれのノードのDOM表現に関する情報をスキーマに含むことです。

```
const schema = new Schema({
  nodes: {
    doc: {content: "paragraph+"},
    paragraph: {
      content: "text*",
      toDOM(node) { return ["p", 0] }
    },
    text: {}
  }
})
```

`["p", 0]` という表現は、paragraphがHTMLの<p>タグとしてレンダリングされることを表しています。0はそのコンテンツがレンダリングされるべき「穴」です。また、タグ名の後にHTML属性を持つオブジェクトを含むこともできます。たとえば `["div", { class: "c"}, 0]` のように。リーフノードはコンテンツを持たないため、DOM表現に「穴」は不要です。

mark specは[toDOM]()と近いものが可能ですが、コンテンツを直接含む単一のタグとしてレンダリングされることを必要とするため、コンテンツは常に直接ノードに入り、穴を指定する必要はありません。

利用者がペーストしたりドラッグして何かをエディタに追加した時などで、DOMデータをもとにドキュメントをパースする必要があります。modelモジュールにはそのための機能も搭載されており、[parseDOMプロパティ]()を使ってスキーマに直接パース情報を含めることが推奨されています。

これは、指定されたノードやmarkに対応するDOM構成を記述した[parse rules]()の配列です。たとえば、basicスキーマはそれらの強調のマークを持っています。

```
  parseDOM: [
    {tag: "em"},                 // Match <em> nodes
    {tag: "i"},                  // and <i> nodes
    {style: "font-style=italic"} // and inline 'font-style: italic'
  ]
```

[tag]()に提供された値はCSSセレクタにできるので、 `div.myclass` のようなことも可能です。同様に、[style]()はインラインのCSSスタイルにマッチします。

スキーマがparseDOMのアノテーションを含む時、[DOMParser.fromSchema]()を使って[DOMParser]()オブジェクトを作ることができます。これはエディタがデフォルトのクリップボードパーサを作成するために行われますが、[オーバーライド]()もできます。

ドキュメントはビルトインのJSONシリアライズ用のフォーマットも搭載しています。オブジェクトから[toJSON]()を呼び出すことで[JSON.stringify]()に安全に渡せるオブジェクトを取得でき、またschemaオブジェクトはこの表現を解析してドキュメントに戻すことができる[nodeFromJSON]()メソッドを持っています。

# Extending a schema

[Schema constructor]()に渡されるnodesやmarksのオプションは、プレーンなJavaScriptオブジェクトと同様の[OrderedMap object]()を取得します。schemaの[spec]().nodes やspec.marksのプロパティの結果は常にPrderedMapであり、さらなるスキーマの基礎として使用できます。
このようなmapは更新版を簡単に作成するいくつかの方法をサポートしています。たとえば `schema.markSpec.remove("blockquote")` はblockquoteのーどが取り除かれたノードの集合を返し、それを新しいスキーマのノードフィールドとして渡すことができます。

[schema-list]()モジュールはこれらのモジュールがエクスポートするノードをのーどセットに追加するための[便利なメソッド]()をエクスポートします。

# Document transformations

[Transforms]()はProseMirrorの動作の中心です。transformは[transaction]()の基礎となり、履歴の追跡や共同編集を可能にするものです。

## Why?

なぜドキュメントをmutateさせて終わりにできないのでしょうか？もしくは少なくとも新しいバージョンのドキュメントを作成しエディタに入れるだけでよいのでは？

それはいくつかの理由があります。1つはコードの明確化です。イミュータブルデータストラクチャは本当にシンプルなコードを推進します。しかしtransform systemが行う主なことは、古いバージョンのドキュメントから新しいバージョンに移行するための個々のステップを表す値という形で更新の痕跡を残すことです。

[undo history]()はこれらのステップを保存し逆に戻すことができます。(ProseMirrorは選択的なundoを実装しており、それは単に以前の状態にロールバックすることよりも複雑です。)

[共同編集]()システムはこれらのステップを他のエディタに送信し、必要があれば再整理します。最終的に全てのエディタを同じドキュメントにするために。

より一般的には、エディタプラグインでは変更が入るたびに検査し適応できるため、非常に便利です。自分自身の状態を他のエディタの状態と矛盾しないようにするためです。

# Steps

ドキュメントの更新は、更新を記述する[steps]()に分解されます。通常、これらを直接操作する必要はありませんが、どのように機能するかを知っておくと便利です。

stepsの例としては、ドキュメントの一部を置き換える[ReplaceStep]()や、与えられた範囲にmarkを付与する[AddMarkStep]()があります。

stepはドキュメントに[applied]()することで、新しいドキュメントを生み出すことができます。

```
console.log(myDoc.toString()) // → p("hello")
// A step that deletes the content between positions 3 and 5
let step = new ReplaceStep(3, 5, Slice.empty)
let result = step.apply(myDoc)
console.log(result.doc.toString()) // → p("heo")
```

stepを適用することは比較的単純なプロセスです。それらはスキーマ制約を守りながらノードを挿入したり、スライスを適合させるために変形させたりといった、気の利いたことは何もしません。それはstepの適用は失敗できることを意味し、例えばノードのオープニングトークンだけを削除しようとした時、それはトークンのバランスを崩してしまい、意味のないことになってしまいます。このように[apply]()は[result object]()を返し、これらは新しいドキュメントかエラーメッセージのどちらかを返します。

通常は、ヘルパー関数でステップを生成させることで、これらのような細かいことを気にする必要がなくなります。

# Transforms

編集アクションは1つかそれ以上のstepsを生成します。一連のステップを処理する最も便利な方法は、[Transform]()オブジェクトを作成することです。(もしくは、完全なeditor stateで作業している場合はTransformのサブクラスである[Transaction]())

```
let tr = new Transform(myDoc)
tr.delete(5, 7) // Delete between position 5 and 7
tr.split(5)     // Split the parent node at position 5
console.log(tr.doc.toString()) // The modified document
console.log(tr.steps.length)   // → 2
```

多くの変形メソッドはtransform自身を返し、チェーンに便利です。( `tr.delete(5).split(5)` のようにできます)

[削除]()や[置換]()、[追加]()や[markの削除]()、[分割]()や[結合]()、[持ち上げ]()や[折り返し]()などのツリー操作のための変形メソッドなどがあります。

# Mapping

ドキュメントを変更するとき、ドキュメント内のpositionが無効になったり意味が変わったりする可能性があります。例えば文字列を1つ挿入するとき、その文字以降の全てのpositionは以前の位置の1つ前のトークンを指すようになります。同様に、ドキュメント内のコンテンツを全て削除する時、全てのコンテンツを指すpositionは全て無効になります。

ドキュメントの変更に伴うpositionの保持が必要な場合がよくあります。例えばselectionの境界線など。これを助けるために、stepsはstepを適用する前と後のドキュメント内のpositionを変換できる[map]()を与えることができます。

```
let step = new ReplaceStep(4, 6, Slice.empty) // Delete 4-5
let map = step.getMap()
console.log(map.map(8)) // → 6
console.log(map.map(2)) // → 2 (nothing changes before the change)
```

Transformオブジェクトは、[Mapping]()と呼ばれる抽象化機能を用いて、その中のstepのmapを自動的に[蓄積]()し、一連のstep mapを一度に見ることができます。

```
let tr = new Transform(myDoc)
tr.split(10)    // split a node, +2 tokens at 10
tr.delete(2, 5) // -3 tokens at 2
console.log(tr.mapping.map(15)) // → 14
console.log(tr.mapping.map(6))  // → 3
console.log(tr.mapping.map(10)) // → 9
```

あるpositionが何にマッピングされるべきか、全くわからないケースもあります。上の例の最後の行を考えてみましょう。position 10は、ノードを分割してトークンを2つ挿入する位置に正確に指し示します。挿入されたコンテンツの後ろの位置にマップされるべきか、それとも前の位置に止まるべきか？この例では、トークンの後に移動しているようです。

しかし、時には他の振る舞いが欲しくなることもあります。そのため、step mapとmappingの[map]()メソッドでは、2番目の引数で `bias` を受け付けます。 bias を-1に設定するとコンテンツがその上に挿入されてもpositionを維持できます。

```
console.log(tr.mapping.map(10, -1)) // → 7
```

個々のstepを小さくわかりやすく定義しているのは、[反転]()stepをロスレスで実施したり、Mapping stepでお互いのposition mapsを確認するなど、こレラのようなマッピングを可能にするためです。

# Rebasing

stepsやposition mapsより複雑なことをする場合、例えば独自の変更追跡機能を実装したり、共同編集機能を統合したりするために、stepをrebaseする必要が出てくるかもしれません。

必要だと確認するまでは、わざわざ勉強する必要はないかもしれません。

rebaseのシンプルなケースとしては、同じドキュメントから始まる2つのステップを取り、片方を変形させて、もう片方で作成したドキュメントに適用できるようにすることがあります。擬似的なコードとしては

```
stepA(doc) = docA
stepB(doc) = docB
stepB(docA) = MISMATCH!
rebase(stepB, mapA) = stepB'
stepB'(docA) = docAB
```

stepは[map]()メソッドを持ち、mappingが渡されると、maps the whole step through it. これは失敗することができ、そのためいくつかのstepは理にかなっていない場合がある。例えば、コンテンツの削除が適用された。しかしそれが成功した時、新しいドキュメントを指すstepを持っている。つまり、



rebaseは難しい…



# The editor state

エディタの状態はどのように作るか？あなたはもちろんあなたのドキュメントを持っている。また現在の選択も持っている。また現在の変更されたmarksの事実を保存するための方法も必要です。例えばmarkが無効や有効かを示す、しかしmarkを含むタイピングを始める前に。

それらはProseMirrorのstateの3つの中心的なコンポーネントであり、state objectsに存在する[doc](), [selection](), and [storedMarks]()

```
import {schema} from "prosemirror-schema-basic"
import {EditorState} from "prosemirror-state"

let state = EditorState.create({schema})
console.log(state.doc.toString()) // An empty paragraph
console.log(state.selection.from) // 1, the start of the paragraph
```

しかしpluginもまたstateに保存する必要があります、例えば、undo historyは変更履歴を保持します。このようにアクティブなpluginのセットもstateに保存され、それらのプラグインは自身のstateに保存するための追加スロットを定義できます。

## Selection

ProseMirrorはいくつかのタイプの選択をサポートしています。(サードパーティのコードによる新しいselection typeの定義もできます。)選択は[Selection]()クラス(またはそのサブクラス)のインスタンスとして表現されます。ドキュメントやその他のstateに関連する値のようにそれらはイミュータブルです。selectionを変更するためには、新しいselectionオブジェクトとそれを保持するための新しいstateを作成します。

selectionは少なくとも、現在のドキュメントを指す位置としてstart([.from]())とend([.to]())を持ちます。多くのselectoinタイプは[anchor]()(移動不可)側と[head]()(移動可能)側を区別し、それらは全てのselectionオブジェクトで必須でもあります。

最も一般的なselectionタイプは[text selection]()で、それは通常カーソル（anchorとheadが同一の時）やテキストの選択として使われます。text selectionの両端は、インラインのposition、すなわちインラインコンテンツを許可するノードを指していることが必要です。

また、コアライブラリでは[ノード選択]()(単一のドキュメントノードを選択すること)もサポートしており、例えばノードをctrl/cmdクリックした時に得られます。この場合、選択範囲はノードの直前のpositionから直後のpositionです。

## Transactions

通常の編集では、新しいstateはその前の状態から派生していきます。状況によっては新しいドキュメントの読み込みなど完全に新しいstateを作りたい場合がありますが、これは例外です。

stateの更新は、既存のstateから[transaction]()を[apply]()することによって起こり、新しいstateを生み出します。概念として、古いstateとtransactionが与えられたら、stateの各要素について新しい値が計算され、それらが新しいstateの値としてまとめられます。

```
let tr = state.tr
console.log(tr.doc.content.size) // 25
tr.insertText("hello") // Replaces selection with 'hello'
let newState = state.apply(tr)
console.log(tr.doc.content.size) // 30
```

[Transaction]()は[Transform]()のサブクラスで、最初のドキュメントに[steps]()を適用して新しいドキュメントを構築する方法を継承しています。これに加えて、transactionはselectionや他のstateに関連する要素を監視し、[replaceSelection]()のようないくつかのselectionに関連する便利なメソッドが得られます。

transactionを作成する最も簡単な方法は、editor stateオブジェクトの[tr]()ゲッターを使うことです。これはstateをベースとした空のトランザクションを作成するので、stepやその他の更新を追加できます。

デフォルトでは、古いselectionはstepを通じて[マッピング]()され新しいselectionを作成しますが、[setSeelection]()を使用して新しいselectionを明示的に設定もできます。

```
let tr = state.tr
console.log(tr.selection.from) // → 10
tr.delete(6, 8)
console.log(tr.selection.from) // → 8 (moved back)
tr.setSelection(TextSelection.create(tr.doc, 3))
console.log(tr.selection.from) // → 3
```

同様に、ドキュメントやselectionの変更により[アクティブなmarkのセット]()が自動的にクリアされ、また[setStoredMarks]()か[ensureMarks]()メソッドによって設定されます。
最後に、[scrollIntoView]()メソッドをしようすると、次にstateが描画されるときに、selectionがビューにスクロールされるようにできます。おそらくほとんどのユーザーアクションでこれを行いたいでしょう。

transformメソッドと同様に、多くのtransactionメソッドはtransaction自身を返すので、チェインに便利です。

# Plugins

新しくstateを[作る]()とき、利用するプラグインの配列を渡すことができます。これらはstateやそこから派生するstateに保存され、transactionの適用方法とstateの振る舞いに基づくエディタの動作の両方に影響を与えることができます。

プラグインは[Plugin class]()のインスタンスで、幅広い機能をモデル化できます。最もシンプルなものは、あるイベントに対応するためにエディタビューにいくつかの[props]()を追加するだけです。より複雑なものではエディタに新しいstateを追加し、transactionに基づいてそれを更新できます。

プラグインを作成する際には、その動作を指定するオブジェクトを渡します。

```
let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log("A key was pressed!")
      return false // We did not handle this
    }
  }
})

let state = EditorState.create({schema, plugins: [myPlugin]})
```

プラグインで自身のstateスロットが必要な場合、[state]()プロパティで定義できます。

```
let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) { return value + 1 }
  }
})

function getTransactionCount(state) {
  return transactionCounter.getState(state)
}
```

この例のプラグインは、あるstateに適用されたトランザクションの数を単純に数えるという、非常にシンプルなstateの断片を定義しています。このヘルパー関数は、プラグインの[getState]()メソッドを使用して、完全なeditor stateオブジェクトからplugin stateを取得します。

editor stateは永続的（immutable）なオブジェクトであり、plugin stateはそのオブジェクトの一部なので、plugin stateの値はimmutableでなければなりません。すなわち、それらのapplyメソッドは、それらが変更される必要がある場合に古いものを変更するのではなく新しい値を返さなければならず、他のコードはそれらを変更してはいけません。

pluginがトランザクションに追加の情報を追加することは、しばしば有用です。たとえば、取り消し履歴は、実際に取り消しを実行するとき、結果のトランザクションをマークします。pluginがそれを見たとき、通常変更に対して行うこと（取り消しスタックに追加する）の代わりに、それを特別に扱い、取り消しスタックの一番上の項目を取り除き、代わりにこのトランザクションをやり直しスタックに追加するようにします。

この目的のために、トランザクションはそれにメタデータを添付できます。このように、マークされたトランザクションを数えないように、トランザクションカウンタープラグインを更新できます。

```
let transactionCounter = new Plugin({
  state: {
    init() { return 0 },
    apply(tr, value) {
      if (tr.getMeta(transactionCounter)) return value
      else return value + 1
    }
  }
})

function markAsUncounted(tr) {
  tr.setMeta(transactionCounter, true)
}
```

メタデータプロパティのキーには文字列を使用できますが、名前の衝突を避けるために、Pluginオブジェクトを使用することが推奨されます。例えば、"addToHistory "をfalseに設定すると、トランザクションを取り消すことができなくなり、ペーストを処理すると、エディタビューは結果のトランザクションの "paste "プロパティをtrueに設定するように、ライブラリによって意味が与えられている文字列キーがいくつかあります。

# The view component

ProseMirrorの[エディタビュー]()は、ユーザに[editor state]()を表示し、その上で編集操作を行うためのユーザインターフェイスコンポーネントです。

編集操作の定義はかなり狭く、タイプ、クリック、コピー、ペースト、ドラッグなど、編集面との直接的なやりとりはできますが、それ以上のことはできません。つまり、メニューの表示やキーバインドなどは、コアビューコンポーネントの担当外であり、プラグインで対応する必要があります。

## Editable DOM

ブラウザでは、DOMの一部を[編集可能]()にできます。ビューは、そのドキュメントの DOM 表現を作成し (デフォルトではschemaの[toDOM]()メソッドを使用します)、それを編集可能にします。編集可能な要素がフォーカスされると、ProseMirrorはDOMの[selection]()がエディタstateでのselectionと一致することを確認します。

また、多くのDOMイベントに対してイベントハンドラを登録し、イベントを適切なトランザクションに変換しています。たとえば、貼り付けを行う場合、貼り付けられたコンテンツは ProseMirror ドキュメントスライスとして解析され、ドキュメントに挿入されます。

また、多くのイベントはそのまま通過させ、ProseMirrorのデータモデルの観点から再解釈されるだけです。たとえば、ブラウザはカーソルと選択範囲の配置に非常に長けているので（双方向テキストを考慮すると、これは本当に難しい問題です）、カーソルの動きに関連するキーとマウスアクションのほとんどはブラウザによって処理され、その後、ProseMirrorは現在のDOM selectionがどの種類のtext selectionに対応するものであるかをチェックします。もしその選択が現在の選択と異なる場合は、選択を更新するトランザクションがディスパッチされます。

スペルチェックやモバイルインターフェイスの自動大文字入力など、ネイティブの機能が壊れてしまうので、タイピングも通常はブラウザに任せます。ブラウザがDOMを更新すると、エディタはそれに気づき、ドキュメントの変更部分を再パースし、その差分をトランザクションに変換します。

## Data flow

つまり、エディタビューは与えられたエディタのstateを表示し、何かが起こるとトランザクションを作成し、これをブロードキャストするのです。このトランザクションは、通常、新しいstateを作成するために使用され、その状態は[updateState]()メソッドを使用してビューに与えられます。

画像

JavaScriptの世界では、多くの命令型イベントハンドラが複雑なデータフローの網を作る傾向がありますが、これとは対照的に、これは単純で周期的なデータフローを作成します。

もしあなたのアプリ全体がこのようなデータフローモデルを使用している場合、Reduxや同様のアーキテクチャと同様に、ProseMirrorのトランザクションをメインのアクションディスパッチサイクルに統合し、ProseMirrorの状態をアプリケーションの「ストア」に保持できます。

```
// The app's state
let appState = {
  editor: EditorState.create({schema}),
  score: 0
}

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({type: "EDITOR_TRANSACTION", transaction})
  }
})

// A crude app state update function, which takes an update object,
// updates the `appState`, and then refreshes the UI.
function update(event) {
  if (event.type == "EDITOR_TRANSACTION")
    appState.editor = appState.editor.apply(event.transaction)
  else if (event.type == "SCORE_POINT")
    appState.score++
  draw()
}

// An even cruder drawing function
function draw() {
  document.querySelector("#score").textContent = appState.score
  view.updateState(appState.editor)
}
```

## Efficient updating

[updateState]()を実装する1つの方法は、それが呼ばれるたびにドキュメントを単純に再描画することです。しかし、大きなドキュメントの場合、それは本当に遅くなる。

更新時には、ビューは古いドキュメントと新しいドキュメントの両方にアクセスできるので、それらを比較し、変更されていないノードに対応する DOM の部分のみを残すことができます。ProseMirrorはこれを行うことで、通常の更新ではほとんど作業しないようにできます。

場合によっては、入力されたテキストに対応する更新のように、ブラウザ自身の編集操作によってすでに DOM に追加されているものもあり、DOM と状態の一貫性を確保するために、DOM を変更する必要はまったくありません。(このようなトランザクションがキャンセルされたり、何らかの方法で変更された場合、ビューは DOM の変更を元に戻して DOM と状態の同期を確保します)。

同様に、DOM の選択は、実際に状態の選択と同期していないときのみ更新されます。これは、ブラウザが選択とともに保持しているさまざまな「隠れた」状態（例えば、短い行を越えて下向きや上向きにすると、次の長い行に入ったときに水平位置が元に戻る機能）を混乱させないようにするためのものです。

## Props

'Props'は、[React]()から取られた、やや曖昧ではあるが便利な用語です。propsは、UIコンポーネントのパラメータのようなものです。理想的には、コンポーネントが取得するpropsのセットは、その動作を完全に定義します。

```
let view = new EditorView({
  state: myState,
  editable() { return false }, // Enables read-only behavior
  handleDoubleClick() { console.log("Double click!") }
})
```

そのため、現在の[state]()が1つのpropとなります。他のpropsの値も、コンポーネントを制御するコードがそれらを更新した場合、時間の経過とともに変化することがありますが、コンポーネント自体はそれらを変更しないので、状態とみなされることはありません。[updateState]()メソッドは、[state prop]()を更新するための単なる略語です。

プラグインはpropを宣言できますが、stateとdispatchTransactionは例外で、ビューに直接提供することだけが可能です。

```
function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) { return state.doc.content.size < max }
    }
  })
}
```

あるpropが複数回宣言された場合、どのように処理されるかはpropに依存します。一般に、直接提供されたpropが優先され、その後に各プラグインが順番に対応します。[domParser]()のようないくつかのpropでは、最初に見つかった値が使用され、他の値は無視されます。イベントを処理したかどうかを示す boolean 値を返すハンドラ関数については、最初に true を返したものがイベントを処理することになります。最後に、[attributes]()（編集可能な DOM ノードに属性を設定するために使用可能）や [decorations]()（次のセクションで説明します）のようないくつかの props については、提供されたすべての値の和が使用されます。

## Decorations

decorationsは、ビューがドキュメントを描画する方法をある程度制御できます。これらは、[decorations props]()から値を返すことで作成され、3つのタイプがあります。

- [Node Decorations]()は、1 つのノードの DOM 表現にスタイルやその他の DOM 属性を追加します。
- [Widget decorations]()は、実際のドキュメントの一部ではない DOM ノードを、指定された位置に挿入します。
- [Inline decorations]()は、ノード装飾と同様に、指定された範囲内のすべてのインラインノードにスタイルや属性を追加します。

装飾を効率的に描画し比較するためには、[decoration set]() (実際のドキュメントのツリー形状を模倣したデータ構造) として提供される必要があります。decoration setoを作成するには、静的メソッド [create]() を使用して、ドキュメントと装飾オブジェクトの配列を指定します。

```
let purplePlugin = new Plugin({
  props: {
    decorations(state) {
      return DecorationSet.create(state.doc, [
        Decoration.inline(0, state.doc.content.size, {style: "color: purple"})
      ])
    }
  }
})
```

decorationsの数が多い場合、再描画のたびにその場でセットを再作成するのはコストがかかりすぎる可能性があります。このような場合、decorationsを維持する方法として推奨されるのは、プラグインのstateにセットを置き、変更時にそれを[マッピング]()し、必要なときだけそれを変更することです。

```
let specklePlugin = new Plugin({
  state: {
    init(_, {doc}) {
      let speckles = []
      for (let pos = 1; pos < doc.content.size; pos += 4)
        speckles.push(Decoration.inline(pos - 1, pos, {style: "background: yellow"}))
      return DecorationSet.create(doc, speckles)
    },
    apply(tr, set) { return set.map(tr.mapping, tr.doc) }
  },
  props: {
    decorations(state) { return specklePlugin.getState(state) }
  }
})
```

このプラグインは、4番目の位置ごとに黄色い背景のインライン装飾を追加する装飾セットで状態を初期化します。これはあまり便利なものではありませんが、検索マッチや注釈付き領域を強調するような用途に似ています。

トランザクションがstateに適用されると、プラグインstateの [apply]() メソッドは、decoration setを前方にマッピングし、装飾が所定の位置にとどまり、新しいドキュメントの形状に「適合」するようにします。このマッピング方法は、装飾セットのツリー形状を利用することで（典型的な局所的変更に対して）効率化されており、変更によって実際に触れるツリーの部分のみが再構築される必要がある。

(実際のプラグインでは、applyメソッドは、新しいイベントに基づいて装飾を追加または削除する場所でもあります。おそらく、トランザクション内の変更を調べたり、トランザクションに添付されたプラグイン固有のメタデータに基づいて行います)

最後に、decorations propsはプラグインのstateを返し、装飾をビューに表示させるだけです。

## Node views

もう一つ、エディタビューの描画方法に影響を与える方法があります。[Node views]()は、ドキュメント内の個々のノードに対して、小型の UI コンポーネントのようなものを[定義]()することを可能にします。このビューでは、ノードの DOM をレンダリングし、ノードの更新方法を定義し、イベントに反応するカスタムコードを記述できます。

```
let view = new EditorView({
  state,
  nodeViews: {
    image(node) { return new ImageView(node) }
  }
})

class ImageView {
  constructor(node) {
    // The editor will use this as the node's DOM representation
    this.dom = document.createElement("img")
    this.dom.src = node.attrs.src
    this.dom.addEventListener("click", e => {
      console.log("You clicked me!")
      e.preventDefault()
    })
  }

  stopEvent() { return true }
}
```

この例で定義されている画像ノード用のビューオブジェクトは、画像用の独自のDOMノードを作成し、イベントハンドラを追加し、stopEventメソッドでProseMirrorがそのDOMノードから来るイベントを無視することを宣言しています。

このノードとのやりとりは、ドキュメント内の実際のノードに何らかの影響を与えたいと思うことがよくあるでしょう。しかし、ノードを変更するトランザクションを作成するには、まず、そのノードがどこにあるのかを知る必要があります。それを助けるために、ノードビューはドキュメント内の現在の位置を問い合わせるために使用できるゲッター関数を渡される。この例を修正して、ノードをクリックすると、画像の alt テキストを入力するようにクエリするようにしてみましょう。

```
let view = new EditorView({
  state,
  nodeViews: {
    image(node, view, getPos) { return new ImageView(node, view, getPos) }
  }
})

class ImageView {
  constructor(node, view, getPos) {
    this.dom = document.createElement("img")
    this.dom.src = node.attrs.src
    this.dom.alt = node.attrs.alt
    this.dom.addEventListener("click", e => {
      e.preventDefault()
      let alt = prompt("New alt text:", "")
      if (alt) view.dispatch(view.state.tr.setNodeMarkup(getPos(), null, {
        src: node.attrs.src,
        alt
      }))
    })
  }

  stopEvent() { return true }
}
```

[setNodeMarkup]()は、指定された位置のノードのタイプまたは属性のセットを変更するために使用できるメソッドです。この例では、getPos を使用して画像の現在の位置を見つけ、新しい alt テキストを含む新しい属性オブジェクトを与えています。

ノードが更新されると、デフォルトの動作は、その外側の DOM 構造をそのままにして、その子を新しい子のセットと比較し、必要に応じてそれらを更新または置換することです。ノードビューは、カスタム動作でこれをオーバーライドできます。これにより、コンテンツに基づいて段落のクラスを変更するようなことが可能になります。

```
let view = new EditorView({
  state,
  nodeViews: {
    paragraph(node) { return new ParagraphView(node) }
  }
})

class ParagraphView {
  constructor(node) {
    this.dom = this.contentDOM = document.createElement("p")
    if (node.content.size == 0) this.dom.classList.add("empty")
  }

  update(node) {
    if (node.type.name != "paragraph") return false
    if (node.content.size > 0) this.dom.classList.remove("empty")
    else this.dom.classList.add("empty")
    return true
  }
}
```

画像は内容を持たないので、先ほどの例では、そのレンダリング方法について心配する必要はありませんでした。しかし、段落にはコンテンツがあります。ProseMirror ライブラリにコンテンツを管理させることもできますし、完全に自分で管理もできます。[contentDOM]() プロパティを指定すると、ライブラリはノードのコンテンツをその中にレンダリングし、コンテンツの更新を処理します。そうしない場合、コンテンツはエディタにとってブラックボックスとなり、どのように表示し、ユーザーに操作させるかは、すべてあなた次第です。

この場合、段落コンテンツは通常の編集可能なテキストのように動作させたいので、コンテンツは外部ノードに直接レンダリングする必要があるため、contentDOMプロパティはdomプロパティと同じになるように定義されています。

マジックは [update]() メソッドで起こります。まず、このメソッドは、ノードビューを更新して新しいノードを表示するかどうかを決定する役割を果たします。この新しいノードは、エディタの更新アルゴリズムがここに描画しようとするものである可能性があるので、このノードビューが処理できるノードであることを確認する必要があります。

この例の更新メソッドは、まず新しいノードが段落であるかどうかをチェックし、そうでない場合はベールアウトします。次に、新しいノードの内容に応じて「空」クラスが存在するかどうかを確認し、更新が成功したことを示す真を返します（この時点でノードのコンテンツが更新されます）。

# Commands

ProseMirrorの専門用語では、コマンドは、ユーザーが何らかのキーの組み合わせを押したり、メニューを操作することによって実行できる編集アクションを実装する関数です。

実用的な理由から、コマンドは少し複雑なインターフェースを持っています。単純に言えば、[editor state]()とディスパッチ関数（[EditorView.dispatch]()またはトランザクションを受け取る他の関数）を受け取り、ブール値を返す関数です。以下は非常に簡単な例です。

```
function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  dispatch(state.tr.deleteSelection())
  return true
}
```

コマンドが適用できないときは、falseを返して何もしない。適用可能な場合は、トランザクションをディスパッチして true を返さなければなりません。これは例えば、キーにバインドされたコマンドが適用されたときに、キーイベントのさらなる処理を停止するために、[keymapプラグイン]()で使用されます。

コマンドを実際に実行することなく、与えられた状態に対してコマンドが適用可能かどうかを問い合わせることができるように、 dispatch 引数はオプションです。コマンドは、適用可能であるが dispatch 引数が与えられていないときには何もせずに単に true を返すべきです。つまり、この例のコマンドは実際には次のようになるはずです。

```
function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false
  if (dispatch) dispatch(state.tr.deleteSelection())
  return true
}
```

選択範囲を削除できるかどうかを調べるには `deleteSelection(view.state, null)` を呼び、実際にコマンドを実行するには `deleteSelection(view.state, view.dispatch)` のような処理をします。メニューバーでは、どのメニュー項目をグレーアウトさせるかを決定するためにこれを使うことができます。

この形式では、コマンドは実際のエディタビューにアクセスできません。ほとんどのコマンドはそれを必要とせず、この方法で、ビューが利用できない設定に適用してテストができます。しかし、いくつかのコマンドはDOMと相互作用する必要があります。与えられた位置がテキストブロックの終わりであるかどうかを問い合わせる必要があったり、ビューに対して相対的に配置されたダイアログを開きたい場合などです。この目的のために、コマンドを呼び出すほとんどのプラグインは、第3引数として全体のビューを渡します。

```
function blinkView(_state, dispatch, view) {
  if (dispatch) {
    view.dom.style.background = "yellow"
    setTimeout(() => view.dom.style.background = "", 1000)
  }
  return true
}
```

この（かなり無駄な）例は、コマンドはトランザクションをディスパッチする必要がないことを示しています。それらはその副作用のために呼ばれます。

[prosemirror-commands]() モジュールは、[deleteSelection]() コマンドの変種のような単純なものから、[joinBackward]() のようなやや複雑なものまで、多くの編集コマンドを提供します。また、スキーマに依存しない多くのコマンドを通常使用されるキーにバインドする基本的なキーマップも付属しています。

可能な限り、通常は1つのキーにバインドされている場合でも、異なる動作は異なるコマンドに入れられる。ユーティリティ関数[chainCommands]()は、いくつかのコマンドを組み合わせるために使用されます-それらは、1つが真を返すまで、次々に試されます。

例えば、基本キーマップでは、backspace をコマンドチェーン deleteSelection（選択範囲が空でないときに実行）、joinBackward（カーソルがテキストブロックの先頭にあるとき）、および selectNodeBackward（スキーマが通常の結合動作を禁止している場合に、選択範囲の前のノードを選択）に結合しています。これらのどれにも当てはまらない場合、ブラウザは独自のバックスペース動作を実行できます。これは、テキストブロック内のバックスペースに適切なものです（ネイティブのスペルチェックなどが混乱しないようにするため）。

例えば、toggleMark はマークの種類とオプションで属性を受け取り、現在の選択部分のマークをトグルするコマンド関数を返します。

他のモジュールでもコマンド関数をエクスポートするものがあります。エディタをカスタマイズしたり、ユーザーが独自のドキュメントノードと対話できるようにするために、独自のカスタムコマンドを書きたい場合もあるでしょう。

# Collaborative editing

リアルタイム共同編集は、複数の人が同じdocumentを同時に編集できます。編集者が行った変更は直ちにローカルドキュメントに適用され、その後ピアに送信され、ピアはこれらの変更を自動的にマージします（手動で競合を解決する必要はありません）。

このガイドでは、ProseMirrorの共同編集機能の配線方法について説明します。

## Algorithm

ProseMirrorの共同編集システムは、変更を適用する順番を決定する中央管理者を採用しています。2人の編集者が同時に変更した場合、2人ともこの権限者に変更内容を報告することになります。権威はどちらかの変更を受け入れ、その変更をすべてのエディタに知らせます。もう一方の変更は受け入れられず、そのエディタはサーバーから新しい変更を受け取ると、ローカルの変更をもう一方のエディタからの変更の上にリベースして、再度投稿しようとしなければならなくなります。

## The Authority
中央機関の役割は、実はかなり単純です。それは...

- 現在のdocumentのバージョンを追跡する。
- 編集者からの変更を受け入れ、適用可能な場合は変更リストに追加する。
- 編集者があるバージョン以降の変更点を受け取る方法を提供する。

エディタと同じ JavaScript 環境で動作する些細な中央権威を実装してみましょう。

```
class Authority {
  constructor(doc) {
    this.doc = doc
    this.steps = []
    this.stepClientIDs = []
    this.onNewSteps = []
  }

  receiveSteps(version, steps, clientID) {
    if (version != this.steps.length) return

    // Apply and accumulate new steps
    steps.forEach(step => {
      this.doc = step.apply(this.doc).doc
      this.steps.push(step)
      this.stepClientIDs.push(clientID)
    })
    // Signal listeners
    this.onNewSteps.forEach(function(f) { f() })
  }

  stepsSince(version) {
    return {
      steps: this.steps.slice(version),
      clientIDs: this.stepClientIDs.slice(version)
    }
  }
}
```

エディタが自分の変更をオーソリティに提出しようとするとき、そのエディタは受信した最後のバージョン番号と、追加した新しい変更、そしてクライアントID（これはどの変更が自分から来たかを後で認識するための方法です）を渡して、その上で受信Stepsを呼び出すことができます。

ステップが受け入れられると、権威が新しいステップが利用可能であることを通知するので、クライアントはそれに気づき、そして自分のステップを与えます。実際の実装では、最適化として receiveSteps がステータスを返し、送信されたステップを直ちに確認もできる。しかし，ここで使われているメカニズムは，信頼性の低い接続での同期を保証するために必要なものなので，常にこれを基本ケースとして使用すべきです。

この権威の実装は，無限に増加するステップの配列を保持し，その長さは現在のバージョンを表します。

## The collab Module

collabモジュールは、ローカルの変更を追跡し、リモートの変更を受信し、何かが中央機関に送信されなければならないときにそれを示すことを引き受けるプラグインを返すcollab関数をエクスポートします。

```
import {EditorState} from "prosemirror-state"
import {EditorView} from "prosemirror-view"
import {schema} from "prosemirror-schema-basic"
import collab from "prosemirror-collab"

function collabEditor(authority, place) {
  let view = new EditorView(place, {
    state: EditorState.create({
      doc: authority.doc,
      plugins: [collab.collab({version: authority.steps.length})]
    }),
    dispatchTransaction(transaction) {
      let newState = view.state.apply(transaction)
      view.updateState(newState)
      let sendable = collab.sendableSteps(newState)
      if (sendable)
        authority.receiveSteps(sendable.version, sendable.steps,
                               sendable.clientID)
    }
  })

  authority.onNewSteps.push(function() {
    let newData = authority.stepsSince(collab.getVersion(view.state))
    view.dispatch(
      collab.receiveTransaction(view.state, newData.steps, newData.clientIDs))
  })

  return view
}
```

collabEditor関数は、collabプラグインが読み込まれたエディタビューを作成します。状態が更新されるたびに、権威に送信するものがあるかどうかをチェックします。もしそうなら、それを送ります。

また、新しいステップが利用可能になったときに権限が呼び出すべき関数を登録し、それらのステップを反映するためにローカルのエディタ状態を更新するトランザクションを作成します。

ステップのセットが権限によって拒否された場合、それらは、おそらくすぐに権限から新しいステップを受け取るまで、未確認のままとなります。その後、onNewSteps コールバックは dispatch を呼び出し、その dispatchTransaction 関数を呼び出すので、コードは再び変更を送信しようとします。

これがすべてです。もちろん、非同期データチャンネル（collabデモのロングポーリングやWebソケットなど）では、もう少し複雑な通信と同期のコードが必要になります。そして、おそらく、メモリ消費量が際限なく増加しないように、権威がある時点でステップを捨て始めるようにしたいと思うでしょう。しかし、一般的なアプローチは、この小さな例で十分に説明できます。
